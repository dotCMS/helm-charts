{{- if .Values.coreServiceEnabled }}
{{- range $envName := keys $.Values.environments }}
{{- with include "myapp.mergeEnvironment" ( mergeOverwrite $ (dict "envName" $envName )) | fromYaml }}
{{- $fullName := include "dotcms.env.fullName" . }}
{{- $dbName := include "dotcms.db.name" . }}
{{- $baseUrl := printf "jdbc:postgresql://%s:%v/%s?ssl.mode=prefer" .Values.database.host ( int .Values.database.port ) $dbName  }}
{{- $namespace := .Values.customerName }}
{{- $licenseSecretName := include "dotcms.secret.shared.name" (dict "Values" .Values "secretName" "license") }}
{{- $licenseSecretExists := ne (lookup "v1" "Secret" $namespace $licenseSecretName) nil }}
{{- $useLicense := default (or $licenseSecretExists .Values.license) .Values.useLicense }}
{{- $configMapMetadata := printf "%s-%s-upgrade-metadata" .Values.customerName .Values.environment }}
{{- $configMapMetadata := printf "%s-%s-upgrade-metadata" .Values.customerName .Values.environment }}
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  namespace: {{ include "dotcms.name.customer" . }}
  name: {{ $fullName }}
  labels:
    {{- if eq $.Values.cloudProvider "aws" }}
    app.dotcms.cloud/aws-region: {{ $.Values.aws.region }}
    {{- end }}
    app.kubernetes.io/instance: {{ $.Values.customerName }}
spec:
  selector:
    matchLabels:
      app: {{ $.Values.app }}
      fullname: {{ $fullName }}
  serviceName: {{ $fullName }}
  replicas: {{ .Values.replicas }}
  template:
    metadata:
      annotations:
        {{- if $.Values.linkerd.enabled }}
        linkerd.io/inject: enabled
        {{- end }}
      labels:
        app: {{ $.Values.app }}
        env: {{ .Values.environment }}
        ver: {{ .Values.environment }}
        cust: {{ $.Values.customerName }}
        fullname: {{ $fullName }}
    spec:
      terminationGracePeriodSeconds: {{ .Values.terminationGracePeriodSeconds }}
      initContainers:
        - name: wait-for-job
          image: groundnuty/k8s-wait-for:no-root-v1.7
          imagePullPolicy: IfNotPresent
          args:
            - job
            - {{ include "dotcms.preUpgradeJobName" . }}-{{ .Release.Revision }}

        {{- if .Values.database.local.enabled }}
        - name: wait-for-db
          image: bitnami/kubectl:1.32.0
          imagePullPolicy: IfNotPresent
          command: ["/bin/bash", "-c"]
          args:
            - |
              echo "Waiting for DB to be ready..."
              kubectl wait --for=condition=Ready pod -l app=db -n {{ $namespace }} --timeout=300s
              echo "DB is ready."            
        {{- end }}
        
        - name: check-backup-restore
          image: bitnami/kubectl:1.32.0
          imagePullPolicy: IfNotPresent
          command: ["/bin/bash", "-c"]
          args:
            - |
              if [ -f /tmp/backupRestore ]; then
                rm /tmp/backupRestore
              fi

              echo "Checking backup/restore operation status from ConfigMap {{ $configMapMetadata }} in namespace {{ $namespace }}..."
              BACKUP_RESTORE_ENABLED=$(kubectl get configmap {{ $configMapMetadata }} -n {{ $namespace }} -o=jsonpath='{.data.backupRestoreEnabled}' 2>/dev/null || echo "false")

              if [ "$BACKUP_RESTORE_ENABLED" == "true" ]; then
                echo "true" > /tmp/backupRestore
              else
                echo "Backup/Restore operation not detected. Skipping container"
              fi
          volumeMounts:
            - name: admin-shared-{{ $envName }}
              mountPath: /tmp

        - name: backup-restore
          image: pgvector/pgvector:pg16
          imagePullPolicy: IfNotPresent
          command: ["/bin/bash", "-c"]
          args:
            - |
              set -ex

              if [ -f /tmp/backupRestore ]; then
                echo "Backup/Restore operation detected."
              else
                echo "Backup/Restore operation not detected. Skipping container"
                exit 0
              fi

              echo "Operation: ${OPERATION}"
              BACKUP_DIR=/mnt/backup
              DOTCMS_DATA_DIR=/data/shared
              RESTORE_TMP_DIR=${BACKUP_DIR}/restore-temp

              if [[ "$OPERATION" == "none" ]]; then
                echo "No backup/restore required."
                exit 0
              fi

              if [[ "${OPERATION}" == "backup" ]]; then
                echo "Starting backup process..."
                DB_DUMP=${BACKUP_DIR}/db-dump.sql
                DOTCMS_DATA=${BACKUP_DIR}/dotcms-data.tar.gz
                FINAL_BACKUP=${BACKUP_DIR}/{{ .Values.fileName | default "backup" }}-$(date +%Y%m%d%H%M%S).tar.gz

                echo "Dumping database..."
                PGPASSWORD=${DB_PASSWORD} pg_dump -h ${DB_HOST} -U ${DB_USERNAME} -d ${DB_NAME} -Fp -f ${DB_DUMP}

                echo "Archiving DotCMS data..."
                tar czf ${DOTCMS_DATA} -C ${DOTCMS_DATA_DIR} .

                echo "Creating final backup..."
                tar czf ${FINAL_BACKUP} -C ${BACKUP_DIR} db-dump.sql dotcms-data.tar.gz

                echo "Backup completed successfully: ${FINAL_BACKUP}"

                rm -rf ${DB_DUMP} ${DOTCMS_DATA}

              elif [[ "${OPERATION}" == "restore" ]]; then
                echo "Starting restore process..."
                mkdir -p ${RESTORE_TMP_DIR}

                echo "Extracting backup..."
                tar xzf ${BACKUP_DIR}/{{ .Values.fileName | default "backup" }}.tar.gz -C ${RESTORE_TMP_DIR}

                DB_EXISTS=$(PGPASSWORD=${DB_PASSWORD} psql -h ${DB_HOST} -U ${DB_USERNAME} -d postgres -tAc "SELECT 1 FROM pg_database WHERE datname = '$DB_NAME';")

                if [ "$DB_EXISTS" == "1" ]; then
                  echo "Database $DB_NAME exists. Dropping it..."
                  PGPASSWORD=${DB_PASSWORD} psql -h ${DB_HOST} -U ${DB_USERNAME} -d postgres -c "DROP DATABASE \"$DB_NAME\";"
                else
                  echo "Database $DB_NAME does not exist. Skipping drop."
                fi

                if ! grep -q "CREATE DATABASE" ${RESTORE_TMP_DIR}/db-dump.sql; then
                  echo "Recreating database $DB_NAME since it's not in the backup..."
                  PGPASSWORD=${DB_PASSWORD} psql -h ${DB_HOST} -U ${DB_USERNAME} -d postgres -c "CREATE DATABASE \"$DB_NAME\" OWNER \"$DB_USERNAME\";"
                else
                  echo "Backup already includes CREATE DATABASE. Skipping creation."
                fi                

                echo "Restoring database..."
                PGPASSWORD=${DB_PASSWORD} psql -h ${DB_HOST} -U ${DB_USERNAME} -d ${DB_NAME} -f ${RESTORE_TMP_DIR}/db-dump.sql

                echo "Restoring DotCMS data..."
                tar xzf ${RESTORE_TMP_DIR}/dotcms-data.tar.gz -C ${DOTCMS_DATA_DIR}

                echo "Restore completed successfully."

              else
                echo "No valid operation specified. Exiting."
              fi
          env:
            - name: OPERATION
              value: {{ .Values.operation }}
            - name: DB_HOST
              value: '{{ .Values.database.host }}.{{ .Values.customerName }}.svc.cluster.local'
            - name: DB_NAME
              value: {{ $dbName }}
            - name: DB_USERNAME
              valueFrom:
                secretKeyRef:
                  name: {{ include "dotcms.secret.shared.name" (dict "Values" .Values "secretName" "db-local-admin") }}
                  key: username
            - name: DB_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: {{ include "dotcms.secret.shared.name" (dict "Values" .Values "secretName" "db-local-admin") }}
                  key: password

          volumeMounts:
            - name: admin-shared-{{ $envName }}
              mountPath: /tmp
            - name: backup-volume-{{ $envName }}
              mountPath: /mnt/backup
            - name: dotcms-shared
              mountPath: /data/shared

        - name: check-upgrade
          image: bitnami/kubectl:1.32.0
          imagePullPolicy: IfNotPresent
          command: ["/bin/bash", "-c"]
          args:
            - |
              if [ -f /tmp/skip ]; then
                rm /tmp/skip
              fi
              echo "Checking upgrade status from ConfigMap {{ $configMapMetadata }} in namespace {{ $namespace }}..."
              UPGRADE_REQUIRED=$(kubectl get configmap {{ $configMapMetadata }} -n {{ $namespace }} -o=jsonpath='{.data.upgradeRequired}' 2>/dev/null || echo "false")
              echo "Upgrade required value: $UPGRADE_REQUIRED"
              if [ "$UPGRADE_REQUIRED" != "true" ]; then
                echo "Upgrade not required. Marking skip..."
                echo "skip" > /tmp/skip                   
              fi            
          volumeMounts:
            - name: admin-shared-{{ $envName }}
              mountPath: /tmp

        - name: dotcms-upgrade      
          {{- include "dotcms.container.spec" (merge (dict "IsUpgradeJob" true "EnableProbes" false "ShutdownOnStartupValue" true "UseLicense" $useLicense) .) | nindent 10 }}
          command: ["/bin/bash", "-c"]
          args:
            - |
              if [ -f /tmp/skip ]; then
                echo "Upgrade not required. Skipping container execution."
              else
                echo "Upgrade required. Launching original entrypoint..."
                echo "env DOT_SHUTDOWN_ON_STARTUP=$DOT_SHUTDOWN_ON_STARTUP"
                exec /srv/entrypoint.sh dotcms
              fi
              exit 0

      containers:
        - name: dotcms
          {{- include "dotcms.container.spec" (merge (dict "IsUpgradeJob" false "EnableProbes" true "ShutdownOnStartupValue" false "useLicense" $useLicense) .) | nindent 10 }}
      {{- if .Values.affinity.requireDifferentHosts }}
      affinity:
        podAntiAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            - labelSelector:
                matchExpressions:
                  - key: fullname
                    operator: In
                    values:
                      - {{ $fullName }}
              topologyKey: kubernetes.io/hostname
        {{- end }}
      volumes:
      - name: admin-shared-{{ $envName }}
        emptyDir: {}
      - name: dotcms-shared
        persistentVolumeClaim:
          claimName: {{ include "dotcms.pvc.env.name" . }}
      - name: backup-volume-{{ $envName }}
        hostPath:
          path: {{ .Values.hostPath }}
          type: DirectoryOrCreate          
      {{- if .Values.secrets.useSecretsStoreCSI }}
      - name: {{ include "dotcms.secret.provider.className"  . }}
        csi:
          driver: secrets-store.csi.k8s.io
          readOnly: true
          volumeAttributes:
            secretProviderClass: {{ include "dotcms.secret.provider.className" .  }}
      {{- end }}
      serviceAccountName: {{ include "dotcms.serviceaccount.app" .  }}

{{- end }}

{{- end }}
{{- end }}
